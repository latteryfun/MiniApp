#include "imports/stdlib.fc";

(cell) dict_get(cell dict, int key) asm "DICTGET";
(int) is_null(cell c) asm "ISNULL";
(int) slice_data_equal?(slice s1, slice s2) asm "SDEQ";

;; Lottery Contract for TON Blockchain
;; Generates random codes based on different methods and time intervals

;; Operation codes for different lottery methods
int op:generate_bronze1() asm "0x42524e31 PUSHINT"; ;; 'BRN1'
int op:generate_bronze2() asm "0x42524e32 PUSHINT"; ;; 'BRN2'
int op:generate_silver1() asm "0x534c5631 PUSHINT"; ;; 'SLV1'
int op:generate_silver2() asm "0x534c5632 PUSHINT"; ;; 'SLV2'
int op:generate_gold1() asm "0x474c4431 PUSHINT"; ;; 'GLD1'
int op:generate_gold2() asm "0x474c4432 PUSHINT"; ;; 'GLD2'
int op:generate_platinum1() asm "0x504c5431 PUSHINT"; ;; 'PLT1'
int op:generate_platinum2() asm "0x504c5432 PUSHINT"; ;; 'PLT2'
int op:generate_jackpot() asm "0x4a41434b PUSHINT"; ;; 'JACK'
int op:get_last_codes() asm "0x474c4153 PUSHINT"; ;; 'GLAS'
int op:get_all_codes() asm "0x47414c4c PUSHINT"; ;; 'GALL'

;; Time intervals for code generation (in seconds)
const BRONZE1_INTERVAL = 43200;  ;; 12 hours
const BRONZE2_INTERVAL = 86400;  ;; 24 hours
const SILVER1_INTERVAL = 172800; ;; 2 days
const SILVER2_INTERVAL = 345600; ;; 4 days
const GOLD1_INTERVAL = 604800;   ;; 7 days
const GOLD2_INTERVAL = 1209600;  ;; 14 days
const PLATINUM1_INTERVAL = 2592000; ;; 30 days
const PLATINUM2_INTERVAL = 5184000; ;; 60 days
const JACKPOT_INTERVAL = 5184000;   ;; 60 days

;; Storage structure:
;; - random_seed: 256-bit integer for random number generation
;; - codes_dict: Dictionary mapping method name to latest CodeRecord
;; - all_codes_dict: Dictionary mapping timestamp to CodeRecord
;; - method_keys_dict: Dictionary mapping method name to list of timestamps
(int, cell, cell, cell) load_storage() impure inline_ref {
  var ds = get_data().begin_parse();
  return (ds~load_uint(256), ds~load_dict(), ds~load_dict(), ds~load_dict());
}

;; Save storage with updated values
() save_storage(int random_seed, cell codes_dict, cell all_codes_dict, cell method_keys_dict) impure inline_ref {
  set_data(begin_cell()
    .store_uint(random_seed, 256)
    .store_dict(codes_dict)
    .store_dict(all_codes_dict)
    .store_dict(method_keys_dict)
  .end_cell());
}

;; Generate a secure random number using block data and message hash
(int) secure_random(int max, slice msg_data) impure inline_ref {
  var (random_seed, _, _, _) = load_storage();
  ;; Combine block data, message hash, and previous seed for entropy
  int entropy = random_seed + now() + cur_lt();
  var msg_hash = sha256(msg_data); ;; Use SHA-256 hash of message data
  int hash_value = msg_hash~load_uint(256);
  ;; Combine entropy with hash for better randomness
  int new_seed = ((entropy * 65537) ^ (hash_value / 17)) % 0xFFFFFFFF;
  if (new_seed < 0) {
    new_seed = new_seed * -1;
  }
  return new_seed % max;
}

;; Generate a random letter (A-Z)
(slice) random_letter(slice msg_data) impure inline_ref {
  slice letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  int index = secure_random(26, msg_data);
  letters~skip_bits(index * 8);
  return letters~load_bits(8);
}

;; Generate a random digit (0-9)
(slice) random_digit(slice msg_data) impure inline_ref {
  int digit = secure_random(10, msg_data);
  slice digits = "0123456789";
  digits~skip_bits(digit * 8);
  return digits~load_bits(8);
}

;; Concatenate two slices into one
(slice) concat_slices(slice a, slice b) inline_ref {
  return begin_cell().store_slice(a).store_slice(b).end_cell().begin_parse();
}

;; Validate method name
(int) is_valid_method(slice method) inline_ref {
  return slice_data_equal?(method, "BRN1") | slice_data_equal?(method, "BRN2") |
         slice_data_equal?(method, "SLV1") | slice_data_equal?(method, "SLV2") |
         slice_data_equal?(method, "GLD1") | slice_data_equal?(method, "GLD2") |
         slice_data_equal?(method, "PLT1") | slice_data_equal?(method, "PLT2") |
         slice_data_equal?(method, "JACK");
}

;; Generate a single code based on the method format
(slice) generate_single_code(slice method, slice msg_data) impure inline_ref {
  ;; Validate method
  if (~is_valid_method(method)) {
    return "";
  }
  if (slice_data_equal?(method, "BRN1") | slice_data_equal?(method, "BRN2")) {
    ;; Format: "A-###" (1 letter, 3 digits)
    slice letter = random_letter(msg_data);
    slice digits = random_digit(msg_data);
    digits = concat_slices(digits, random_digit(msg_data));
    digits = concat_slices(digits, random_digit(msg_data));
    return concat_slices(letter, concat_slices("-", digits));
  }
  if (slice_data_equal?(method, "SLV1") | slice_data_equal?(method, "SLV2")) {
    ;; Format: "A-####" (1 letter, 4 digits)
    slice letter = random_letter(msg_data);
    slice digits = random_digit(msg_data);
    digits = concat_slices(digits, random_digit(msg_data));
    digits = concat_slices(digits, random_digit(msg_data));
    digits = concat_slices(digits, random_digit(msg_data));
    return concat_slices(letter, concat_slices("-", digits));
  }
  if (slice_data_equal?(method, "GLD1") | slice_data_equal?(method, "GLD2")) {
    ;; Format: "AA-####" (2 letters, 4 digits)
    slice letter = random_letter(msg_data);
    letter = concat_slices(letter, random_letter(msg_data));
    slice digits = random_digit(msg_data);
    digits = concat_slices(digits, random_digit(msg_data));
    digits = concat_slices(digits, random_digit(msg_data));
    digits = concat_slices(digits, random_digit(msg_data));
    return concat_slices(letter, concat_slices("-", digits));
  }
  if (slice_data_equal?(method, "PLT1") | slice_data_equal?(method, "PLT2")) {
    ;; Format: "AAA-####" (3 letters, 4 digits)
    slice letter = random_letter(msg_data);
    letter = concat_slices(letter, random_letter(msg_data));
    letter = concat_slices(letter, random_letter(msg_data));
    slice digits = random_digit(msg_data);
    digits = concat_slices(digits, random_digit(msg_data));
    digits = concat_slices(digits, random_digit(msg_data));
    digits = concat_slices(digits, random_digit(msg_data));
    return concat_slices(letter, concat_slices("-", digits));
  }
  if (slice_data_equal?(method, "JACK")) {
    ;; Format: "AAA-######" (3 letters, 6 digits)
    slice letter = random_letter(msg_data);
    letter = concat_slices(letter, random_letter(msg_data));
    letter = concat_slices(letter, random_letter(msg_data));
    slice digits = random_digit(msg_data);
    digits = concat_slices(digits, random_digit(msg_data));
    digits = concat_slices(digits, random_digit(msg_data));
    digits = concat_slices(digits, random_digit(msg_data));
    digits = concat_slices(digits, random_digit(msg_data));
    digits = concat_slices(digits, random_digit(msg_data));
    return concat_slices(letter, concat_slices("-", digits));
  }
  return "";
}

;; Check if it's time to generate new codes for a method
(int) should_generate(slice method, int last_timestamp) impure inline_ref {
  ;; Return true if no previous codes exist
  if (last_timestamp == 0) {
    return 1;
  }
  
  int current_time = now();
  int elapsed = current_time - last_timestamp;
  
  ;; Check if enough time has elapsed for the method
  if (slice_data_equal?(method, "BRN1")) { return elapsed >= BRONZE1_INTERVAL; }
  if (slice_data_equal?(method, "BRN2")) { return elapsed >= BRONZE2_INTERVAL; }
  if (slice_data_equal?(method, "SLV1")) { return elapsed >= SILVER1_INTERVAL; }
  if (slice_data_equal?(method, "SLV2")) { return elapsed >= SILVER2_INTERVAL; }
  if (slice_data_equal?(method, "GLD1")) { return elapsed >= GOLD1_INTERVAL; }
  if (slice_data_equal?(method, "GLD2")) { return elapsed >= GOLD2_INTERVAL; }
  if (slice_data_equal?(method, "PLT1")) { return elapsed >= PLATINUM1_INTERVAL; }
  if (slice_data_equal?(method, "PLT2")) { return elapsed >= PLATINUM2_INTERVAL; }
  if (slice_data_equal?(method, "JACK")) { return elapsed >= JACKPOT_INTERVAL; }
  
  return 0;
}

;; Generate codes for a specific method
() generate_method_codes(slice method, slice msg_data) impure {
  ;; Load storage
  var (random_seed, codes_dict, all_codes_dict, method_keys_dict) = load_storage();
  
  ;; Validate method
  if (~is_valid_method(method)) {
    return (); ;; Exit if method is invalid
  }
  
  int method_hash = method~load_uint(32);
  var record_cell = dict_get(codes_dict, method_hash);
  int last_timestamp = 0;
  if (is_null(record_cell) == 0) {
    var record_slice = record_cell.begin_parse();
    last_timestamp = record_slice~load_uint(32);
  }

  ;; Determine the interval for the method
  int interval = 0;
  if (slice_data_equal?(method, "BRN1")) { interval = BRONZE1_INTERVAL; }
  if (slice_data_equal?(method, "BRN2")) { interval = BRONZE2_INTERVAL; }
  if (slice_data_equal?(method, "SLV1")) { interval = SILVER1_INTERVAL; }
  if (slice_data_equal?(method, "SLV2")) { interval = SILVER2_INTERVAL; }
  if (slice_data_equal?(method, "GLD1")) { interval = GOLD1_INTERVAL; }
  if (slice_data_equal?(method, "GLD2")) { interval = GOLD2_INTERVAL; }
  if (slice_data_equal?(method, "PLT1")) { interval = PLATINUM1_INTERVAL; }
  if (slice_data_equal?(method, "PLT2")) { interval = PLATINUM2_INTERVAL; }
  if (slice_data_equal?(method, "JACK")) { interval = JACKPOT_INTERVAL; }

  int current_time = now();
  int next_time = last_timestamp == 0 ? current_time : last_timestamp + interval;

  ;; Generate new codes if enough time has elapsed
  while (next_time <= current_time) {
    slice code1 = generate_single_code(method, msg_data);
    slice code2 = generate_single_code(method, msg_data);
    slice code3 = generate_single_code(method, msg_data);

    ;; Check if generated codes are valid
    if (slice_data_equal?(code1, "") | slice_data_equal?(code2, "") | slice_data_equal?(code3, "")) {
      return (); ;; Exit if any code is invalid
    }

    cell new_record = begin_cell()
      .store_uint(next_time, 32)
      .store_slice(code1)
      .store_slice(code2)
      .store_slice(code3)
    .end_cell();

    ;; Update codes_dict with the new record
    codes_dict = dict_set(codes_dict, method_hash, "", new_record.begin_parse());

    ;; Update all_codes_dict with the new record
    all_codes_dict = dict_set(all_codes_dict, next_time, "", begin_cell()
      .store_slice(method)
      .store_uint(next_time, 32)
      .store_slice(code1)
      .store_slice(code2)
      .store_slice(code3)
    .end_cell().begin_parse());

    ;; Update method_keys_dict to store the timestamp
    cell method_keys = dict_get(method_keys_dict, method_hash);
    if (is_null(method_keys)) {
      method_keys = new_dict();
    }
    method_keys = dict_set(method_keys, next_time, "", begin_cell().store_uint(next_time, 32).end_cell().begin_parse());
    method_keys_dict = dict_set(method_keys_dict, method_hash, "", method_keys.begin_parse());

    next_time = next_time + interval;
  }

  ;; Update storage only once after code generation
  save_storage(random_seed + 1, codes_dict, all_codes_dict, method_keys_dict);
}

;; Generate codes for all methods
() generate_all_codes(slice msg_data) impure {
  slice methods = "BRN1BRN2SLV1SLV2GLD1GLD2PLT1PLT2JACK";
  int i = 0;
  while (i < 9) {
    slice method = methods;
    method~skip_bits(i * 4 * 8); 
    method = method~load_bits(4 * 8);
    generate_method_codes(method, msg_data);
    i = i + 1;
  }
}

;; Handle internal messages to generate codes
() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {
  var cs = in_msg_cell.begin_parse();
  cs~skip_bits(4); ;; Skip message flags
  slice sender = cs~load_msg_addr();

  if (in_msg.slice_bits() < 32) {
    ;; Ignore empty or invalid messages
    return ();
  }
  
  int op = in_msg~load_uint(32);

  ;; Handle different operations
  if (op == op:generate_bronze1()) { generate_method_codes("BRN1", in_msg); }
  elseif (op == op:generate_bronze2()) { generate_method_codes("BRN2", in_msg); }
  elseif (op == op:generate_silver1()) { generate_method_codes("SLV1", in_msg); }
  elseif (op == op:generate_silver2()) { generate_method_codes("SLV2", in_msg); }
  elseif (op == op:generate_gold1()) { generate_method_codes("GLD1", in_msg); }
  elseif (op == op:generate_gold2()) { generate_method_codes("GLD2", in_msg); }
  elseif (op == op:generate_platinum1()) { generate_method_codes("PLT1", in_msg); }
  elseif (op == op:generate_platinum2()) { generate_method_codes("PLT2", in_msg); }
  elseif (op == op:generate_jackpot()) { generate_method_codes("JACK", in_msg); }
  else { generate_all_codes(in_msg); } ;; Generate all codes for any other message
}

;; Get the latest codes for all methods
cell get_last_codes() method_id {
  var (_, codes_dict, _, _) = load_storage();
  ;; Return codes_dict if not empty, otherwise return empty dictionary
  if (is_null(codes_dict)) {
    return new_dict();
  }
  return codes_dict;
}

;; Get all historical codes
cell get_all_codes() method_id {
  var (_, _, all_codes_dict, _) = load_storage();
  ;; Return all_codes_dict if not empty, otherwise return empty dictionary
  if (is_null(all_codes_dict)) {
    return new_dict();
  }
  return all_codes_dict;
}

;; Get the latest code for a specific method
cell get_last_code_by_type(slice method) method_id {
  ;; Validate method
  if (~is_valid_method(method)) {
    return begin_cell().end_cell();
  }
  var (_, codes_dict, _, _) = load_storage();
  int method_hash = method~load_uint(32);
  var record_cell = dict_get(codes_dict, method_hash);
  if (is_null(record_cell) == 0) {
    return record_cell;
  }
  return begin_cell().end_cell();
}

;; Get all codes for a specific method using method_keys_dict
cell get_all_codes_by_type(slice method) method_id {
  ;; Validate method
  if (~is_valid_method(method)) {
    return new_dict();
  }
  var (_, _, all_codes_dict, method_keys_dict) = load_storage();
  cell filtered = new_dict();
  int i = 0;
  
  ;; Get the list of timestamps for the method
  int method_hash = method~load_uint(32);
  var method_keys = dict_get(method_keys_dict, method_hash);
  if (is_null(method_keys)) {
    return new_dict(); ;; No keys for this method
  }
  
  ;; Iterate through the timestamps
  int key = 0;
  int max_iterations = 1000000; ;; Prevent infinite loops
  while (key < max_iterations) {
    var timestamp_cell = dict_get(method_keys, key);
    if (is_null(timestamp_cell)) {
      key = max_iterations; ;; Exit loop if no more keys
    } else {
      var timestamp_slice = timestamp_cell.begin_parse();
      int timestamp = timestamp_slice~load_uint(32);
      var value = dict_get(all_codes_dict, timestamp);
      if (is_null(value) == 0) {
        var rec_slice = value.begin_parse();
        slice rec_method = rec_slice~load_bits(4 * 8);
        if (slice_data_equal?(rec_method, method)) {
          filtered = dict_set(filtered, i, "", value.begin_parse());
          i = i + 1;
        }
      }
      key = key + 1;
    }
  }
  
  return filtered;
}

;; Initialize contract with external message
() recv_external(slice in_msg) impure {
  ;; Initialize storage with random seed if not set
  var (random_seed, codes_dict, all_codes_dict, method_keys_dict) = load_storage();
  if (random_seed == 0) {
    random_seed = now() + cur_lt();
    codes_dict = new_dict();
    all_codes_dict = new_dict();
    method_keys_dict = new_dict();
    save_storage(random_seed, codes_dict, all_codes_dict, method_keys_dict);
  }
  generate_all_codes(in_msg);
}